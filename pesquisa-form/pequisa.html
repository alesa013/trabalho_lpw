<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pesquisa</title>
</head>
<body>
    <h1>Assincronismo</h1>
    <p>
    <br>
   1) AJAX (Asynchronous Javascript And XML)<br>É uma técnica que permite a comunicação assíncrona entre o cliente (navegador) e o servidor, permitindo a atualização de partes de uma página web sem recarregá-la por completo.
    <!-- Exemplo:
    <!DOCTYPE html>
<html>
<body>
<div id="demo">
<h2>The XMLHttpRequest Object</h2>
<button type="button" onclick="loadDoc()">Change Content</button>
</div>
<script>
function loadDoc() {
  const xhttp = new XMLHttpRequest();
  xhttp.onload = function() {
	document.getElementById("demo").innerHTML =
	this.responseText;
  }
  xhttp.open("GET", "ajax_info.txt");
  xhttp.send();
}
</script>
</body>
</html>
Esse código cria uma página HTML simples com um botão que, ao ser clicado, faz uma requisição AJAX para carregar o conteúdo de um arquivo chamado "ajax_info.txt" e exibi-lo dentro de um elemento div.<br>

    2) Promises<br>são uma maneira de lidar com operações assíncronas, fornecendo uma maneira mais clara e eficiente de encadear operações do que callbacks. Uma Promise representa um valor que pode estar disponível agora, no futuro ou nunca.
    Ela pode ter três estados:<br>
Pendente (Pending): A operação ainda está em andamento.<br>
Resolvida (Fulfilled): A operação foi concluída com sucesso.<br>
Rejeitada (Rejected): A operação falhou.<br>
<!-- Exemplo:
let promise = new Promise((resolve, reject) => {
  let success = true; // Sucesso ou fracasso da operação
  if (success) {
    resolve("Deu certo!"); // Promessa cumprida
  } else {
    reject("Algo deu errado!"); // Promessa rejeitada
  }
});

promise
  .then(result => console.log(result)) // "Deu certo"
  .catch(error => console.log(error)); // "Algo deu errado"

Nesse, você faz uma promessa, e o then é chamado se tudo der certo, e o catch se algo der errado. -->
    <br>
        
    3) Fetch API<br>é uma interface moderna para fazer requisições HTTP em JavaScript. Ela substitui a antiga XMLHttpRequest e facilita a comunicação com servidores, permitindo buscar recursos de forma assíncrona. A Fetch API retorna Promises.
    <!-- Exemplo:
       fetch('https://api.example.com/data')
  .then(response => {
	if (!response.ok) {
  	throw new Error('Network response was not ok');
	}
	return response.json(); // Converte a resposta para JSON
  })
  .then(data => {
	console.log(data); // Aqui você usa os dados da resposta
  })
  .catch(error => {
	console.error('There was a problem with the fetch operation:', error);
  });

Esse código faz uma requisição para um servidor, verifica se a resposta foi boa, converte os dados para JSON, e em caso de erro, mostra a mensagem de erro no console. Como a URL aqui é inválida, vai dar erro.
        
    A Fetch API facilita lidar com dados remotos (como APIs), evitando recarregamento de páginas. -->
    <br>
        
    4) Async / Await<br>é uma sintaxe mais clara e simples para trabalhar com operações assíncronas em JavaScript, que facilita o uso de Promises.
        O Async define que uma função vai trabalhar de forma assíncrona, retornando implicitamente uma Promise. O Await pausa a execução da função até que a Promise seja resolvida ou rejeitada, sem bloquear o restante do código.
    <!-- Exemplo:
       async function fetchData() {
  try {
	const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
	if (!response.ok) {
  	throw new Error('Network response was not ok');
	}
	const data = await response.json(); // Converte a resposta para JSON
	console.log(data); // Exibe os dados no console
  } catch (error) {
	console.error('There was a problem with the fetch operation:', error);
  }
}

fetchData(); // Chama a função

Nesse exemplo, ele faz uma requisição para a URL fornecida e exibe o resultado no console. Se houver algum erro (como problema na rede ou resposta inválida), ele será capturado no bloco catch.
<br>
        
    5) Quais as vantagens/desvantagens de usar cada uma das opções acima?<br>O AJAX é ompatível com navegadores antigos, permitindo requisições assíncronas, mas com uma sintaxe complicada e difícil de manter.<br>
    A Fetch API proporciona um código mais limpo e legível com Promises, facilitando o fluxo de requisições.<br>
    E o async/await torna o código ainda mais sequencial e fácil de entender, simplificando o tratamento de erros com try/catch e exigindo navegadores modernos.<br>
    </p>
    
    <h1>Outros tópicos</h1><br>
    <p>
        <br>
        1) Hoisting<br>Hoisting é o comportamento padrão do JavaScript de mover declarações para o topo.<br>
        <br>
        2) Arrow Functions (especialmente diferenças com relação as funções normais)<br>As funções de seta permitem uma sintaxe curta para escrever expressões de função,Você não precisa da function-palavra-chave, da return-palavra-chave e das chaves<br>
        <br>
        3) Desestruturação (Destructuring)<br>Podemos ter um array ou objeto com o qual estamos trabalhando, mas precisamos apenas de alguns dos itens contidos neles, A desestruturação facilita a extração apenas do que é necessário.<br>
        <br>
        4) Closure<br>Closure é uma linguagem dinâmica que combina interatividade e eficiência em multithreading, com fácil acesso a frameworks Java e suporte a tipos opcionais.<br>
    </p>

</body>
</html>
